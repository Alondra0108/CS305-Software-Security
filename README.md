Artemis Financial – Project One: Software Security Vulnerability Assessment

Developer: Alondra Paulino Santos
Course: CS-305 Software Security
Client: Artemis Financial

Artemis Financial is a financial services company that specializes in creating personalized investment, insurance, and retirement plans for clients. Because the company handles highly sensitive financial and personal information, its main requirement was to improve the security of its web application and ensure that all communication between clients and servers is protected. My task was to identify and mitigate vulnerabilities in their existing codebase and dependencies, focusing on encryption, secure coding, and compliance with data protection standards such as PCI DSS and the Gramm–Leach–Bliley Act (GLBA). Essentially, Artemis wanted to strengthen its trust with clients by ensuring its systems followed the “security is everyone’s responsibility” philosophy.

During the assessment, one thing I did particularly well was performing a detailed manual review of the application code and catching real security risks, such as hardcoded credentials, missing input validation, and weak error handling. I also did a strong static dependency check that identified several outdated libraries like Tomcat, Spring, and Jackson—all of which carried known vulnerabilities. Coding securely is important because even a single weak point, like an unvalidated input or exposed API key, can compromise the entire system. Implementing secure coding practices doesn’t just protect user data—it also protects the company’s reputation and operational continuity. In Artemis’s case, adding security value meant protecting financial data, maintaining client confidence, and ensuring long-term business stability through compliance and resilience against attacks.

The most challenging part of the vulnerability assessment was tracing how each dependency affected the application’s overall security. Because so many libraries were interconnected, one outdated component could create multiple risk points. However, this process was also the most educational. It helped me understand how transitive dependencies work and why dependency management is critical in secure software development. I also found the manual review section helpful because it trained me to spot real-world coding mistakes, like SQL injection risks or poor encapsulation, which are easy to miss during regular development.

To strengthen the system, I increased the layers of security by addressing vulnerabilities both in the code and in the dependency stack. In the code, I removed hardcoded credentials, implemented proper input validation, and improved encapsulation and error handling. On the dependency side, I updated outdated libraries such as Spring, Jackson, and Tomcat to their patched versions to eliminate known CVEs. Moving forward, I would continue using automated tools like OWASP Dependency-Check, Snyk, or GitHub Dependabot for regular scanning, along with manual code reviews and threat modeling. I would also apply frameworks like OWASP Top 10 and NIST guidelines to decide which mitigation techniques best fit each type of risk.

After refactoring the code, I verified that the system still worked as expected by testing endpoints and reviewing functionality across the application. I re-ran the OWASP Dependency-Check tool to confirm that no new vulnerabilities were introduced after updates. I also double-checked that input validation, encryption, and logging changes didn’t affect normal application behavior. This process ensured that the application remained both functional and secure after modifications.

Some of the most helpful tools I used included the OWASP Dependency-Check plugin for Maven, which scanned and listed all vulnerable libraries, and Logback for secure error handling and structured logging. I also relied on OWASP secure coding practices and Java best practices like encapsulation, parameterized queries, and validation annotations (@Valid, @Pattern). These tools and techniques will be useful in future projects because they help establish a consistent workflow for secure development and maintenance.

Overall, this project demonstrates my ability to perform a professional-level vulnerability assessment and apply secure coding principles in a real-world scenario. It shows that I can identify risks, recommend mitigation strategies, and document findings clearly for both technical and non-technical audiences. For future employers, I can showcase this project as evidence of my understanding of secure software design, dependency management, and practical implementation of encryption and validation in Java-based applications.
